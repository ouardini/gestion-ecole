import * as ts from "typescript";
import * as tsutils from "tsutils";
import { InternalSymbolName } from "typescript";
export function couldBeFunction(type) {
    return (type.getCallSignatures().length > 0) ||
        couldBeType(type, "Function") ||
        couldBeType(type, "ArrowFunction") ||
        couldBeType(type, InternalSymbolName.Function);
}
export function couldBeType(type, name, qualified) {
    if (isReferenceType(type)) {
        type = type.target;
    }
    if (isType(type, name, qualified)) {
        return true;
    }
    if (isIntersectionType(type) || isUnionType(type)) {
        return type.types.some(function (t) { return couldBeType(t, name, qualified); });
    }
    var baseTypes = type.getBaseTypes();
    if (!baseTypes) {
        return false;
    }
    return baseTypes.some(function (t) { return couldBeType(t, name, qualified); });
}
export function findDeclaration(node, typeChecker) {
    var symbol = typeChecker.getSymbolAtLocation(node);
    if (!symbol) {
        return undefined;
    }
    var declarations = symbol.getDeclarations();
    if (!declarations || (declarations.length === 0)) {
        return undefined;
    }
    var declaration = declarations[0];
    return declaration;
}
export function isAny(type) {
    return tsutils.isTypeFlagSet(type, ts.TypeFlags.Any);
}
export function isConstDeclaration(declaration) {
    var variableDeclarationList = null;
    if (tsutils.isVariableDeclaration(declaration)) {
        if (tsutils.isVariableDeclarationList(declaration.parent)) {
            variableDeclarationList = declaration.parent;
        }
    }
    else if (tsutils.isBindingElement(declaration)) {
        var parent = declaration.parent;
        while (tsutils.isBindingPattern(parent) || tsutils.isVariableDeclaration(parent)) {
            parent = parent.parent;
        }
        if (tsutils.isVariableDeclarationList(parent)) {
            variableDeclarationList = parent;
        }
    }
    if (variableDeclarationList) {
        return tsutils.getVariableDeclarationKind(variableDeclarationList) === tsutils.VariableDeclarationKind.Const;
    }
    return false;
}
export function isInstanceofCtor(node) {
    var parent = node.parent;
    return tsutils.isBinaryExpression(parent) &&
        (node === parent.right) &&
        (parent.operatorToken.kind === ts.SyntaxKind.InstanceOfKeyword);
}
export function isIntersectionType(type) {
    return tsutils.isTypeFlagSet(type, ts.TypeFlags.Intersection);
}
export function isReferenceType(type) {
    return tsutils.isTypeFlagSet(type, ts.TypeFlags.Object) &&
        tsutils.isObjectFlagSet(type, ts.ObjectFlags.Reference);
}
export function isThis(node) {
    return node.kind === ts.SyntaxKind.ThisKeyword;
}
export function isType(type, name, qualified) {
    if (!type.symbol) {
        return false;
    }
    if (qualified && !qualified.name.test(qualified.typeChecker.getFullyQualifiedName(type.symbol))) {
        return false;
    }
    return (typeof name === "string") ?
        (type.symbol.name === name) :
        Boolean(type.symbol.name.match(name));
}
export function isUnionType(type) {
    return tsutils.isTypeFlagSet(type, ts.TypeFlags.Union);
}
export function isWithinCallExpressionExpression(node) {
    var parent = node.parent;
    while (parent && tsutils.isPropertyAccessExpression(parent)) {
        node = parent;
        parent = node.parent;
    }
    return parent && tsutils.isCallExpression(parent) && (node === parent.expression);
}
export function isWithinParameterDeclaration(node) {
    if (tsutils.isParameterDeclaration(node)) {
        return true;
    }
    return tsutils.isBindingElement(node) &&
        tsutils.isBindingPattern(node.parent) &&
        tsutils.isParameterDeclaration(node.parent.parent);
}
