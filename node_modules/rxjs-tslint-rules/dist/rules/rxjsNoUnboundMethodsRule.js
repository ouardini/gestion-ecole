"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Lint = require("tslint");
var tsutils = require("tsutils");
var peer = require("../support/peer");
var tsquery_1 = require("@phenomnomnominal/tsquery");
var util_1 = require("../support/util");
var Rule = (function (_super) {
    tslib_1.__extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.applyWithProgram = function (sourceFile, program) {
        var _this = this;
        var failures = [];
        var typeChecker = program.getTypeChecker();
        var propertyAccessExpressions = tsquery_1.tsquery(sourceFile, "CallExpression PropertyAccessExpression[name.name=/^(add|pipe|subscribe)$/]");
        propertyAccessExpressions.forEach(function (node) {
            var propertyAccessExpression = node;
            var callExpression = propertyAccessExpression.parent;
            if (tsutils.isCallExpression(callExpression)) {
                var type = typeChecker.getTypeAtLocation(propertyAccessExpression.expression);
                if (util_1.couldBeType(type, /^(Observable|Subscription)$/)) {
                    var args = callExpression.arguments;
                    var name_1 = propertyAccessExpression.name;
                    if (name_1.getText() === "pipe") {
                        args.forEach(function (arg) {
                            if (tsutils.isCallExpression(arg)) {
                                _this.validateArgs(arg.arguments, sourceFile, typeChecker, failures);
                            }
                        });
                    }
                    else {
                        _this.validateArgs(args, sourceFile, typeChecker, failures);
                    }
                }
            }
        });
        var subscriptionIdentifiers = tsquery_1.tsquery(sourceFile, "NewExpression Identifier[escapedText=\"Subscription\"]");
        subscriptionIdentifiers.forEach(function (subscriptionIdentifier) {
            var newExpression = subscriptionIdentifier.parent;
            if (tsutils.isNewExpression(newExpression)) {
                _this.validateArgs(newExpression.arguments, sourceFile, typeChecker, failures);
            }
        });
        return failures;
    };
    Rule.prototype.validateArgs = function (args, sourceFile, typeChecker, failures) {
        var _this = this;
        args.forEach(function (arg) {
            if (tsutils.isPropertyAccessExpression(arg)) {
                var type = typeChecker.getTypeAtLocation(arg);
                if (type.getCallSignatures().length > 0) {
                    var thisKeywords = tsquery_1.tsquery(arg, "ThisKeyword");
                    if (thisKeywords.length > 0) {
                        failures.push(new Lint.RuleFailure(sourceFile, arg.getStart(), arg.getStart() + arg.getWidth(), Rule.FAILURE_STRING, _this.ruleName));
                    }
                }
            }
        });
    };
    Rule.metadata = {
        deprecationMessage: peer.v5 || peer.compat ? "Rule is v6-only." : undefined,
        description: "Disallows the passing of unbound methods.",
        options: null,
        optionsDescription: "Not configurable.",
        requiresTypeInfo: true,
        ruleName: "rxjs-no-unbound-methods",
        type: "maintainability",
        typescriptOnly: true
    };
    Rule.FAILURE_STRING = "Unbound methods are forbidden";
    return Rule;
}(Lint.Rules.TypedRule));
exports.Rule = Rule;
